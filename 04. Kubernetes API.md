## 4 Giới thiệu về các đối tượng API của Kubernetes
Chương này bao gồm:

* Quản lý một cụm Kubernetes và các ứng dụng mà nó lưu trữ thông qua API của nó
* Hiểu cấu trúc của các đối tượng API Kubernetes
* Lấy và hiểu tệp manifest YAML hoặc JSON của một đối tượng
* Kiểm tra trạng thái của các nút cụm thông qua các đối tượng Node
* Kiểm tra các sự kiện cụm thông qua các đối tượng Event

Chương trước đã giới thiệu ba đối tượng cơ bản tạo nên một ứng dụng đã triển khai. Bạn đã tạo một đối tượng Deployment để sinh ra nhiều đối tượng Pod, mỗi Pod đại diện cho một phiên bản riêng lẻ của ứng dụng của bạn, và sau đó phơi bày chúng ra bên ngoài bằng cách tạo một đối tượng Service triển khai bộ cân bằng tải phía trước chúng.

Các chương trong phần thứ hai của cuốn sách này sẽ giải thích chi tiết các loại đối tượng này và các loại khác. Trong chương này, các đặc điểm chung của các đối tượng Kubernetes sẽ được trình bày bằng cách sử dụng ví dụ về các đối tượng Node và Event.

---

## 4.1 Làm quen với API của Kubernetes

Trong một cụm Kubernetes, cả người dùng và các thành phần của Kubernetes đều tương tác với cụm bằng cách thao tác các đối tượng thông qua API của Kubernetes, như minh họa trong hình 4.1.

Các đối tượng này đại diện cho cấu hình của toàn bộ cụm. Chúng bao gồm các ứng dụng đang chạy trong cụm, cấu hình của chúng, các bộ cân bằng tải qua đó chúng được phơi bày trong cụm hoặc ra bên ngoài, các máy chủ cơ sở và bộ lưu trữ được các ứng dụng này sử dụng, quyền bảo mật của người dùng và ứng dụng, và nhiều chi tiết khác của hạ tầng.

**Hình 4.1** Một cụm Kubernetes được cấu hình bằng cách thao tác các đối tượng trong API Kubernetes

![](https://img001.prntscr.com/file/img001/OOOSBUXjRxCfSn4lpooMoQ.png)
---

### 4.1.1 Giới thiệu về API

API của Kubernetes là điểm tương tác trung tâm với cụm, vì vậy phần lớn cuốn sách này dành để giải thích API này. Các đối tượng API quan trọng nhất sẽ được mô tả trong các chương tiếp theo, nhưng phần giới thiệu cơ bản về API được trình bày ở đây.

**Hiểu phong cách kiến trúc của API**

API của Kubernetes là một API RESTful dựa trên HTTP, trong đó trạng thái được biểu diễn bởi các tài nguyên (resources) mà bạn thực hiện các thao tác CRUD (Tạo, Đọc, Cập nhật, Xóa) bằng các phương thức HTTP tiêu chuẩn như POST, GET, PUT/PATCH hoặc DELETE.

**Định nghĩa**
REST là viết tắt của Representational State Transfer, một phong cách kiến trúc để triển khai khả năng tương tác giữa các hệ thống máy tính thông qua các dịch vụ web bằng các thao tác không trạng thái, được mô tả bởi Roy Thomas Fielding trong luận án tiến sĩ của ông. Để tìm hiểu thêm, hãy đọc luận án tại:
[https://www.ics.uci.edu/\~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).

Chính các tài nguyên này (hay đối tượng) đại diện cho cấu hình của cụm. Do đó, quản trị viên cụm và kỹ sư triển khai ứng dụng vào cụm sẽ ảnh hưởng đến cấu hình bằng cách thao tác các đối tượng này.

Trong cộng đồng Kubernetes, các thuật ngữ “resource” và “object” được sử dụng thay thế cho nhau, nhưng có những khác biệt tinh tế cần giải thích.

---

**Hiểu sự khác biệt giữa resources và objects**

Khái niệm cốt lõi trong các API RESTful là *resource* (tài nguyên), và mỗi tài nguyên được gán một URI hoặc *Uniform Resource Identifier* để xác định duy nhất nó.

Ví dụ: trong API Kubernetes, các triển khai ứng dụng được đại diện bởi các tài nguyên *deployment*.

Tập hợp tất cả các deployment trong cụm là một tài nguyên REST được phơi bày tại `/api/v1/deployments`. Khi bạn sử dụng phương thức GET để gửi một yêu cầu HTTP đến URI này, bạn sẽ nhận được phản hồi liệt kê tất cả các phiên bản triển khai trong cụm.

Mỗi phiên bản triển khai riêng lẻ cũng có URI duy nhất của riêng nó để có thể thao tác. Do đó, mỗi deployment riêng lẻ được phơi bày như một tài nguyên REST khác. Bạn có thể lấy thông tin về deployment bằng cách gửi một yêu cầu GET đến URI tài nguyên và có thể chỉnh sửa nó bằng yêu cầu PUT.

**Hình 4.2** Một đối tượng đơn có thể được phơi bày bởi hai hoặc nhiều tài nguyên

![](https://img001.prntscr.com/file/img001/CPnGAP_aRpaWiPWCearb4w.png)
Do đó, một đối tượng có thể được phơi bày qua nhiều hơn một tài nguyên. Như minh họa trong hình 4.2, phiên bản đối tượng Deployment tên *mydeploy* được trả về cả khi bạn truy vấn tài nguyên *deployments* và khi bạn truy vấn URI tài nguyên riêng lẻ trực tiếp.

Ngoài ra, một phiên bản đối tượng đơn cũng có thể được phơi bày qua nhiều tài nguyên nếu tồn tại nhiều phiên bản API cho một loại đối tượng.

Cho đến Kubernetes phiên bản 1.15, hai biểu diễn khác nhau của các đối tượng Deployment được phơi bày bởi API. Ngoài phiên bản `apps/v1`, được phơi bày tại `/apis/apps/v1/deployments`, một phiên bản cũ hơn `extensions/v1beta1`, được phơi bày tại `/apis/extensions/v1beta1/deployments` cũng có sẵn trong API.

Hai tài nguyên này không đại diện cho hai tập hợp đối tượng Deployment khác nhau, mà là một tập hợp duy nhất được biểu diễn theo hai cách khác nhau - với một vài khác biệt nhỏ trong schema đối tượng. Bạn có thể tạo một phiên bản của đối tượng Deployment qua URI đầu tiên và sau đó đọc nó bằng URI thứ hai.

Trong một số trường hợp, một tài nguyên không đại diện cho bất kỳ đối tượng nào. Ví dụ là cách API Kubernetes cho phép client xác minh xem một chủ thể (một người hoặc một dịch vụ) có được phép thực hiện một thao tác API hay không. Điều này được thực hiện bằng cách gửi một yêu cầu POST đến tài nguyên `/apis/authorization.k8s.io/v1/subjectaccessreviews`.

Phản hồi cho biết chủ thể có được phép thực hiện thao tác được chỉ định trong nội dung yêu cầu hay không. Điều quan trọng ở đây là không có đối tượng nào được tạo ra bởi yêu cầu POST.

Các ví dụ ở trên cho thấy rằng *resource* không giống với *object*. Nếu bạn quen thuộc với hệ thống cơ sở dữ liệu quan hệ, bạn có thể so sánh *resources* và *object types* với *views* và *tables*. *Resources* là các *views* mà qua đó bạn tương tác với các đối tượng.

**Lưu ý**
Bởi vì thuật ngữ “resource” cũng có thể ám chỉ đến tài nguyên tính toán như CPU và bộ nhớ, để giảm nhầm lẫn, thuật ngữ “objects” sẽ được sử dụng trong cuốn sách này để chỉ các tài nguyên API.

---

**Hiểu cách các đối tượng được biểu diễn**

Khi bạn thực hiện một yêu cầu GET cho một tài nguyên, máy chủ API Kubernetes trả về đối tượng ở dạng văn bản có cấu trúc. Mô hình dữ liệu mặc định là JSON, nhưng bạn cũng có thể yêu cầu máy chủ trả về YAML.

Khi bạn cập nhật đối tượng bằng yêu cầu POST hoặc PUT, bạn cũng chỉ định trạng thái mới với JSON hoặc YAML.

Các trường riêng trong manifest của một đối tượng phụ thuộc vào loại đối tượng, nhưng cấu trúc tổng quát và nhiều trường được chia sẻ bởi tất cả các đối tượng API Kubernetes. Bạn sẽ tìm hiểu về chúng ngay sau đây.

---

### 4.1.2 Hiểu cấu trúc của một manifest đối tượng

Trước khi bạn đối mặt với manifest hoàn chỉnh của một đối tượng Kubernetes, hãy để tôi giải thích các phần chính của nó trước, vì điều này sẽ giúp bạn định hướng trong hàng trăm dòng mã mà nó có thể chứa.

---

**Giới thiệu các phần chính của một đối tượng**

Manifest của hầu hết các đối tượng API Kubernetes bao gồm bốn phần sau:

* **Type Metadata**: Chứa thông tin về loại đối tượng mà manifest này mô tả. Nó chỉ định loại đối tượng, nhóm mà loại đó thuộc về, và phiên bản API.
* **Object Metadata**: Chứa thông tin cơ bản về phiên bản đối tượng, bao gồm tên, thời gian tạo, chủ sở hữu của đối tượng và các thông tin nhận dạng khác. Các trường trong *Object Metadata* giống nhau cho tất cả các loại đối tượng.
* **Spec**: Phần mà bạn chỉ định trạng thái mong muốn của đối tượng. Các trường của nó khác nhau giữa các loại đối tượng. Đối với Pod, đây là phần chỉ định các container của pod, các volume lưu trữ và các thông tin khác liên quan đến hoạt động của nó.
* **Status**: Chứa trạng thái thực tế hiện tại của đối tượng. Đối với Pod, nó cho bạn biết tình trạng của pod, trạng thái của từng container, địa chỉ IP của nó, node mà nó đang chạy, và các thông tin khác cho thấy điều gì đang xảy ra với pod của bạn.

Biểu diễn trực quan của manifest đối tượng và bốn phần của nó được minh họa trong hình tiếp theo.

**Hình 4.3** Các phần chính của một đối tượng API Kubernetes

![](https://img001.prntscr.com/file/img001/2Eb2OnlaTU-wSIMsyllxLw.png)

**Lưu ý**
Mặc dù hình minh họa cho thấy người dùng ghi vào phần *Spec* của đối tượng và đọc phần *Status*, nhưng máy chủ API luôn trả về toàn bộ đối tượng khi bạn thực hiện yêu cầu GET; để cập nhật đối tượng, bạn cũng gửi toàn bộ đối tượng trong yêu cầu PUT.

Bạn sẽ thấy một ví dụ sau để xem các trường nào tồn tại trong các phần này, nhưng trước tiên hãy để tôi giải thích các phần *Spec* và *Status*, vì chúng đại diện cho phần cốt lõi của đối tượng.

---

**Hiểu các phần spec và status**

Như bạn có thể thấy trong hình trước, hai phần quan trọng nhất của một đối tượng là *Spec* và *Status*.

* Bạn sử dụng *Spec* để chỉ định trạng thái mong muốn của đối tượng.
* Bạn đọc trạng thái thực tế của đối tượng từ *Status*.

Vậy, bạn là người ghi *Spec* và đọc *Status*, nhưng ai hoặc cái gì đọc *Spec* và ghi *Status*?

Control Plane của Kubernetes chạy nhiều thành phần gọi là *controller* để quản lý các đối tượng mà bạn tạo. Mỗi controller thường chỉ chịu trách nhiệm cho một loại đối tượng. Ví dụ, *Deployment controller* quản lý các đối tượng Deployment.

Như minh họa trong hình 4.4, nhiệm vụ của một controller là đọc trạng thái mong muốn từ phần *Spec* của đối tượng, thực hiện các hành động cần thiết để đạt được trạng thái này, và báo cáo trạng thái thực tế của đối tượng bằng cách ghi vào phần *Status*.

**Hình 4.4** Cách một controller quản lý một đối tượng

![](https://img001.prntscr.com/file/img001/qGOstAwNTxGue-YBTUkJMw.png)

Về cơ bản, bạn nói cho Kubernetes biết phải làm gì bằng cách tạo và cập nhật các đối tượng API. Các controller của Kubernetes sử dụng cùng các đối tượng API để cho bạn biết chúng đã làm gì và trạng thái công việc của chúng.

Bạn sẽ tìm hiểu thêm về các controller riêng lẻ và trách nhiệm của chúng trong chương 13. Bây giờ, chỉ cần nhớ rằng một controller được liên kết với hầu hết các loại đối tượng và controller là thành phần đọc *Spec* và ghi *Status* của đối tượng.

---

**Không phải tất cả các đối tượng đều có phần spec và status**

Tất cả các đối tượng API Kubernetes đều chứa hai phần metadata, nhưng không phải đối tượng nào cũng có phần *Spec* và *Status*.

Những đối tượng không có các phần này thường chỉ chứa dữ liệu tĩnh và không có controller tương ứng, vì vậy không cần phân biệt giữa trạng thái mong muốn và trạng thái thực tế của đối tượng.

Ví dụ về một đối tượng như vậy là đối tượng *Event*, được tạo bởi nhiều controller để cung cấp thông tin bổ sung về những gì đang xảy ra với một đối tượng mà controller đang quản lý. Đối tượng *Event* được giải thích trong mục 4.3.

Bây giờ bạn đã hiểu cấu trúc tổng thể của một đối tượng, vì vậy phần tiếp theo của chương này cuối cùng có thể khám phá các trường riêng lẻ của một đối tượng.


## 4.2 Kiểm tra các thuộc tính riêng lẻ của một đối tượng
Để kiểm tra chi tiết các đối tượng API của Kubernetes, chúng ta cần một ví dụ cụ thể.
Hãy lấy đối tượng **Node** làm ví dụ, vì nó tương đối dễ hiểu do nó đại diện cho thứ mà bạn có thể quen thuộc – một máy tính trong cụm (cluster).

Cụm Kubernetes của tôi được cung cấp bởi công cụ **kind** có ba node – một master và hai worker. Chúng được biểu diễn bằng ba đối tượng **Node** trong API. Tôi có thể truy vấn API và liệt kê các đối tượng này bằng cách sử dụng:



```bash
$ kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
kind-control-plane   Ready    master   1h    v1.18.2
kind-worker          Ready    <none>   1h    v1.18.2
kind-worker2         Ready    <none>   1h    v1.18.2
```

Hình sau minh họa ba đối tượng **Node** và các máy trong cụm thực tế tạo nên cụm này. Mỗi phiên bản đối tượng **Node** đại diện cho một host. Trong mỗi phiên bản, phần **Spec** chứa (một phần) cấu hình của host, và phần **Status** chứa trạng thái của host.

**Hình 4.5** Các node trong cụm được biểu diễn bằng các đối tượng **Node**

![](https://img001.prntscr.com/file/img001/nVvOWBBeQl6qEBr0-hgZ9g.png)

**Lưu ý**
Các đối tượng **Node** hơi khác so với các đối tượng khác vì chúng thường được tạo bởi **Kubelet** – tác nhân node chạy trên node của cụm – chứ không phải bởi người dùng. Khi bạn thêm một máy vào cụm, **Kubelet** sẽ đăng ký node bằng cách tạo một đối tượng **Node** đại diện cho host. Người dùng sau đó có thể chỉnh sửa (một số) trường trong phần **Spec**.

---

### 4.2.1 Khám phá manifest đầy đủ của một đối tượng Node

Hãy xem xét kỹ hơn một trong các đối tượng **Node**. Liệt kê tất cả các đối tượng **Node** trong cụm của bạn bằng lệnh:

```bash
kubectl get nodes
```

và chọn một node bạn muốn kiểm tra. Sau đó, chạy:

```bash
kubectl get node <node-name> -o yaml
```

Trong đó, thay `<node-name>` bằng tên node, ví dụ:

```bash
kubectl get node kind-control-plane -o yaml
```

![](https://img001.prntscr.com/file/img001/Oeu4fvmkStitB2cawj8X_g.png)

**Lưu ý**
Sử dụng tùy chọn **-o json** để hiển thị đối tượng ở dạng **JSON** thay vì **YAML**.

Trong manifest YAML, bốn phần chính của định nghĩa đối tượng và các thuộc tính quan trọng hơn của node được chú thích để giúp bạn phân biệt giữa các trường quan trọng và ít quan trọng hơn. Một số dòng đã bị lược bớt để giảm độ dài của manifest.

---

### Truy cập trực tiếp API

Bạn có thể quan tâm đến việc truy cập trực tiếp API thay vì thông qua **kubectl**. Như đã giải thích trước đó, API của Kubernetes dựa trên web, vì vậy bạn có thể sử dụng trình duyệt web hoặc lệnh **curl** để thực hiện các thao tác API. Tuy nhiên, máy chủ API sử dụng **TLS** và bạn thường cần chứng chỉ hoặc token của client để xác thực.

May mắn thay, **kubectl** cung cấp một proxy đặc biệt xử lý việc này, cho phép bạn giao tiếp với API thông qua proxy bằng HTTP thuần túy.

Để chạy proxy, thực hiện lệnh:

```bash
$ kubectl proxy
Starting to serve on 127.0.0.1:8001
```

Bây giờ bạn có thể truy cập API qua HTTP tại **127.0.0.1:8001**. Ví dụ, để truy xuất đối tượng node, mở URL:

```
http://127.0.0.1:8001/api/v1/nodes/kind-control-plane
```

(thay **kind-control-plane** bằng tên node của bạn).

---

Bây giờ hãy xem xét kỹ hơn các trường trong từng phần chính.

#### Các trường Type Metadata

Như bạn thấy, manifest bắt đầu với các trường **apiVersion** và **kind**, trường này chỉ định phiên bản API và loại đối tượng mà manifest này định nghĩa.

* **apiVersion**: là schema được sử dụng để mô tả đối tượng này. Một loại đối tượng có thể được liên kết với nhiều schema khác nhau, mỗi schema có các trường khác nhau để mô tả đối tượng. Tuy nhiên, thường chỉ có một schema duy nhất cho mỗi loại.
* Trong manifest trước, **apiVersion** là **v1**, nhưng ở các chương tiếp theo, bạn sẽ thấy **apiVersion** ở các loại đối tượng khác chứa nhiều thông tin hơn chỉ số phiên bản. Ví dụ, với các đối tượng **Deployment**, **apiVersion** là **apps/v1**. Ban đầu trường này chỉ để chỉ phiên bản API, nhưng giờ nó cũng được dùng để chỉ nhóm API mà tài nguyên thuộc về.

Đối tượng **Node** thuộc về nhóm API **core**, nhóm này thường được bỏ qua trong trường **apiVersion**.

* **kind**: chỉ loại đối tượng được định nghĩa trong manifest. Trong manifest trước, **kind** là **Node**. Ở các chương trước, bạn đã tạo các đối tượng **Deployment**, **Service**, và **Pod**.

---

#### Các trường trong Object Metadata

Phần **metadata** chứa siêu dữ liệu của phiên bản đối tượng này. Nó bao gồm tên của phiên bản, cùng các thuộc tính bổ sung như **labels** và **annotations** (được giải thích trong chương 9), và các trường như **resourceVersion**, **managedFields**, cùng các trường cấp thấp khác (được giải thích chi tiết trong chương 12).

---

#### Các trường trong phần Spec

Tiếp theo là phần **spec**, phần này đặc thù cho từng loại đối tượng.

* Với đối tượng **Node**, phần này tương đối ngắn so với các loại đối tượng khác.
* Trường **podCIDR** chỉ dải IP pod được gán cho node. Các pod chạy trên node này sẽ được gán IP từ dải này.
* Trường **taints** chưa quan trọng ở thời điểm này, bạn sẽ học về nó trong chương 18.

Thông thường, phần **spec** của một đối tượng chứa nhiều trường hơn để bạn cấu hình đối tượng.

---

#### Các trường trong phần Status

Phần **status** cũng khác nhau giữa các loại đối tượng, nhưng mục đích của nó luôn giống nhau – chứa trạng thái được quan sát lần cuối của thứ mà đối tượng đại diện.

Đối với đối tượng **Node**, **status** cho biết:

* địa chỉ IP của node,
* tên host,
* khả năng cung cấp tài nguyên tính toán,
* điều kiện hiện tại của node,
* các image container mà node đã tải về và hiện được cache cục bộ,
* thông tin về hệ điều hành và phiên bản của các thành phần Kubernetes đang chạy trên node.

---

### 4.2.2 Hiểu các trường riêng lẻ của đối tượng

Để tìm hiểu thêm về các trường riêng lẻ trong manifest, bạn có thể tham khảo tài liệu API tại:

```
http://kubernetes.io/docs/reference/
```

hoặc sử dụng lệnh **kubectl explain** như mô tả dưới đây.

---

#### Sử dụng kubectl explain để khám phá các trường của đối tượng API

Công cụ **kubectl** có một tính năng cho phép bạn tra cứu giải thích của từng trường cho từng loại đối tượng ngay từ dòng lệnh.

Thông thường, bạn bắt đầu bằng cách yêu cầu nó cung cấp mô tả cơ bản của loại đối tượng bằng lệnh:

```bash
$ kubectl explain nodes
KIND: Node
VERSION: v1
DESCRIPTION:
  Node là một worker node trong Kubernetes. Mỗi node sẽ có một
  định danh duy nhất trong bộ nhớ đệm (ví dụ: trong etcd).
FIELDS:
  apiVersion <string>
    APIVersion định nghĩa schema phiên bản của đối tượng này.
    Máy chủ sẽ chuyển đổi schema nhận dạng được sang phiên bản mới nhất...
  kind <string>
    Kind là giá trị chuỗi đại diện cho tài nguyên REST mà đối tượng này
    biểu diễn. Máy chủ có thể suy ra từ endpoint mà client sử dụng...
  metadata <Object>
    Siêu dữ liệu chuẩn của đối tượng. Thông tin thêm: ...
  spec <Object>
    Spec định nghĩa hành vi của node...
  status <Object>
    Trạng thái được quan sát gần đây nhất của node. Do hệ thống điền.
    Chỉ đọc. Thông tin thêm: ...
```

Lệnh này in ra giải thích của đối tượng và liệt kê các trường cấp cao nhất mà đối tượng có thể chứa.

---

#### Đi sâu hơn vào cấu trúc của đối tượng API

Bạn có thể đi sâu hơn để tìm các trường con dưới từng trường cụ thể. Ví dụ, bạn có thể sử dụng lệnh sau để giải thích trường **spec** của node:

```bash
$ kubectl explain node.spec
KIND: Node
VERSION: v1
RESOURCE: spec <Object>
DESCRIPTION:
  Spec định nghĩa hành vi của một node.
  NodeSpec mô tả các thuộc tính mà một node được tạo ra với.
FIELDS:
  configSource <Object>
    Nếu được chỉ định, nguồn để lấy cấu hình node từ đó.
    Cần bật cờ tính năng DynamicKubeletConfig cho Kubelet...
  externalID <string>
    Không còn dùng nữa. Không phải tất cả kubelet sẽ đặt trường này...
  podCIDR <string>
    PodCIDR đại diện cho dải IP pod được gán cho node.
```

Lưu ý phiên bản API ở đầu. Như đã giải thích, có thể tồn tại nhiều phiên bản của cùng một loại. Các phiên bản khác nhau có thể có các trường hoặc giá trị mặc định khác nhau.

Nếu bạn muốn hiển thị phiên bản khác, hãy chỉ định nó bằng tùy chọn **--api-version**.

**Lưu ý**
Nếu bạn muốn xem cấu trúc đầy đủ của một đối tượng (danh sách phân cấp đầy đủ các trường mà không có mô tả), hãy thử:

```bash
kubectl explain pods --recursive
```


### 4.2.3 Hiểu về các điều kiện trạng thái (status conditions) của một đối tượng

Tập hợp các trường trong cả hai phần **spec** và **status** là khác nhau với mỗi loại đối tượng, nhưng trường **conditions** lại xuất hiện trong nhiều loại đối tượng. Nó cung cấp danh sách các điều kiện mà đối tượng hiện đang có. Những điều kiện này rất hữu ích khi bạn cần xử lý sự cố của một đối tượng, vì vậy chúng ta hãy xem xét kỹ hơn. Vì đối tượng **Node** được sử dụng làm ví dụ, nên phần này cũng sẽ hướng dẫn bạn cách xác định dễ dàng các vấn đề với một node trong cluster.

---

#### Giới thiệu về các điều kiện trạng thái của node

Hãy in ra manifest YAML của một trong các đối tượng **Node**, nhưng lần này chúng ta chỉ tập trung vào trường **conditions** trong phần **status** của đối tượng. Lệnh và kết quả như sau:

```bash
$ kubectl get node kind-control-plane -o yaml
...
status:
  ...
  conditions:
  - lastHeartbeatTime: "2020-05-17T13:03:42Z"
    lastTransitionTime: "2020-05-03T15:09:17Z"
    message: kubelet has sufficient memory available
    reason: KubeletHasSufficientMemory
    status: "False"   #A
    type: MemoryPressure   #A
  - lastHeartbeatTime: "2020-05-17T13:03:42Z"
    lastTransitionTime: "2020-05-03T15:09:17Z"
    message: kubelet has no disk pressure
    reason: KubeletHasNoDiskPressure
    status: "False"   #B
    type: DiskPressure   #B
  - lastHeartbeatTime: "2020-05-17T13:03:42Z"
    lastTransitionTime: "2020-05-03T15:09:17Z"
    message: kubelet has sufficient PID available
    reason: KubeletHasSufficientPID
    status: "False"   #C
    type: PIDPressure   #C
  - lastHeartbeatTime: "2020-05-17T13:03:42Z"
    lastTransitionTime: "2020-05-03T15:10:15Z"
    message: kubelet is posting ready status
    reason: KubeletReady
    status: "True"    #D
    type: Ready    #D
```

**Mẹo**
Công cụ **jq** rất tiện lợi nếu bạn chỉ muốn xem một phần của cấu trúc đối tượng. Ví dụ, để hiển thị các điều kiện trạng thái của node, bạn có thể chạy:

```bash
kubectl get node <name> -o json | jq .status.conditions
```

Công cụ tương đương cho YAML là **yq**.

---

Có bốn điều kiện cho biết trạng thái của node. Mỗi điều kiện có một trường **type** và một trường **status**, có thể nhận giá trị **True**, **False** hoặc **Unknown**, như minh họa trong **hình 4.6**.

Một điều kiện cũng có thể chỉ định **reason** dành cho máy móc về lần chuyển trạng thái cuối cùng, và một **message** dành cho con người với thông tin chi tiết về lần chuyển trạng thái đó.

Trường **lastTransitionTime** cho biết thời điểm điều kiện chuyển từ trạng thái này sang trạng thái khác, trong khi trường **lastHeartbeatTime** cho biết thời điểm bộ điều khiển nhận được bản cập nhật mới nhất về điều kiện đó.

**Hình 4.6** Các điều kiện trạng thái biểu thị tình trạng của một đối tượng **Node**

![](https://img001.prntscr.com/file/img001/AdVlDGasTw6rw54ebDOdjg.png)
Mặc dù là điều kiện cuối cùng trong danh sách, **Ready** có lẽ là điều kiện quan trọng nhất vì nó cho biết node có sẵn sàng nhận workload mới (pod) hay không.

Các điều kiện khác (**MemoryPressure**, **DiskPressure**, **PIDPressure**) cho biết node có đang cạn kiệt tài nguyên hay không. Hãy nhớ kiểm tra các điều kiện này nếu một node bắt đầu hoạt động bất thường – ví dụ, nếu các ứng dụng chạy trên đó bắt đầu cạn kiệt tài nguyên và/hoặc bị crash.

---

#### Hiểu các điều kiện trong những loại đối tượng khác

Danh sách điều kiện như trong đối tượng **Node** cũng được sử dụng trong nhiều loại đối tượng khác. Những điều kiện được giải thích ở trên là ví dụ điển hình cho lý do tại sao trạng thái của hầu hết các đối tượng được biểu diễn bởi nhiều điều kiện thay vì một trường duy nhất.

**Lưu ý**
Các điều kiện thường **độc lập** với nhau, nghĩa là chúng biểu diễn những khía cạnh không liên quan của đối tượng.

Nếu trạng thái của một đối tượng được biểu diễn dưới dạng một trường duy nhất, sẽ rất khó để mở rộng nó với các giá trị mới sau này, vì điều đó sẽ yêu cầu cập nhật tất cả các client đang giám sát trạng thái của đối tượng và thực hiện hành động dựa trên đó.

Một số loại đối tượng ban đầu sử dụng một trường duy nhất như vậy, và một số vẫn còn, nhưng hầu hết hiện nay đều sử dụng danh sách các điều kiện.

Vì trọng tâm của chương này là giới thiệu các tính năng chung của các đối tượng Kubernetes API, chúng ta chỉ tập trung vào trường **conditions**, nhưng đây không phải là trường duy nhất trong phần **status** của đối tượng **Node**.

Để khám phá các trường khác, hãy sử dụng lệnh `kubectl explain` như đã mô tả trong phần trước. Các trường mà bạn chưa hiểu ngay bây giờ sẽ trở nên rõ ràng hơn sau khi đọc các chương tiếp theo trong phần này của cuốn sách.

**Lưu ý**
Như một bài tập, hãy sử dụng lệnh:

```bash
kubectl get <kind> <name> -o yaml
```

để khám phá các đối tượng khác mà bạn đã tạo cho đến nay (**deployments**, **services**, và **pods**).

---

### 4.2.4 Kiểm tra đối tượng bằng lệnh kubectl describe

Để mang lại cho bạn cái nhìn đầy đủ về cấu trúc của các đối tượng Kubernetes API, chúng ta cần hiển thị toàn bộ manifest YAML của một đối tượng.

Mặc dù cá nhân tôi thường sử dụng phương pháp này để kiểm tra đối tượng, nhưng một cách thân thiện hơn với người dùng để kiểm tra đối tượng là lệnh `kubectl describe`, lệnh này thường hiển thị cùng một thông tin hoặc thậm chí nhiều hơn.

---

#### Hiểu đầu ra của lệnh kubectl describe với một đối tượng Node

Hãy thử chạy lệnh `kubectl describe` trên một đối tượng **Node**. Để thú vị hơn, hãy dùng nó để mô tả một trong các node **worker** thay vì node **master**.

Lệnh và kết quả như sau:

```bash
$ kubectl describe node kind-worker-2
Name:           kind-worker2
Roles:          <none>
Labels:         beta.kubernetes.io/arch=amd64
                beta.kubernetes.io/os=linux
                kubernetes.io/arch=amd64
                kubernetes.io/hostname=kind-worker2
                kubernetes.io/os=linux
Annotations:    kubeadm.alpha.kubernetes.io/cri-socket: /run/contain...
                node.alpha.kubernetes.io/ttl: 0
                volumes.kubernetes.io/controller-managed-attach-deta...
CreationTimestamp: Sun, 03 May 2020 17:09:48 +0200
Taints:         <none>
Unschedulable:  false
Lease:
  HolderIdentity:  kind-worker2
  AcquireTime:     <unset>
  RenewTime:       Sun, 17 May 2020 16:15:03 +0200
Conditions:
  Type              Status  ...  Reason                       Message
  ----              ------  ---  ------                       -------
  MemoryPressure     False   ...  KubeletHasSufficientMemory    ...
  DiskPressure       False   ...  KubeletHasNoDiskPressure       ...
  PIDPressure        False   ...  KubeletHasSufficientPID        ...
  Ready              True    ...  KubeletReady                  ...
Addresses:
  InternalIP:        172.18.0.4
  Hostname:          kind-worker2
Capacity:
  cpu:                   8
  ephemeral-storage:      401520944Ki
  hugepages-1Gi:           0
  hugepages-2Mi:           0
  memory:                  32720824Ki
  pods:                    110
Allocatable:
  ...
System Info:
  ...
PodCIDR:                  10.244.1.0/24
PodCIDRs:                 10.244.1.0/24
Non-terminated Pods:       (2 in total)
  Namespace      Name                  CPU Requests  CPU Limits  ...  AGE
  ---------      ----                  ------------  ----------  ...  ---
  kube-system    kindnet-4xmjh          100m (1%)     100m (1%)   ...  13d
  kube-system    kube-proxy-dgkfm       0 (0%)        0 (0%)      ...  13d
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests       Limits
  --------           --------       ------
  cpu                100m (1%)       100m (1%)
  memory             50Mi (0%)       50Mi (0%)
  ephemeral-storage   0 (0%)          0 (0%)
  hugepages-1Gi        0 (0%)          0 (0%)
  hugepages-2Mi        0 (0%)          0 (0%)
Events:
  Type    Reason                       Age     From                  Message
  ----    ------                       ----    ----                  -------
  Normal  Starting                     3m50s   kubelet, kind-worker2  ...
  Normal  NodeAllocatableEnforced       3m50s   kubelet, kind-worker2  ...
  Normal  NodeHasSufficientMemory       3m50s   kubelet, kind-worker2  ...
  Normal  NodeHasNoDiskPressure         3m50s   kubelet, kind-worker2  ...
  Normal  NodeHasSufficientPID          3m50s   kubelet, kind-worker2  ...
  Normal  Starting                     3m49s   kube-proxy, kind-worker2 ...
```

Như bạn thấy, lệnh `kubectl describe` hiển thị tất cả thông tin mà trước đây bạn thấy trong manifest YAML của đối tượng **Node**, nhưng dưới dạng dễ đọc hơn. Bạn có thể thấy tên, địa chỉ IP, hostname, cũng như các điều kiện và dung lượng có sẵn của node.

---

#### Kiểm tra các đối tượng khác liên quan đến Node

Ngoài thông tin được lưu trữ trong chính đối tượng **Node**, lệnh `kubectl describe` cũng hiển thị các pod đang chạy trên node và tổng số tài nguyên tính toán đã được cấp phát cho chúng.

Ngoài ra còn có danh sách các sự kiện liên quan đến node.

Thông tin bổ sung này không nằm trong chính đối tượng **Node** mà được công cụ **kubectl** thu thập từ các đối tượng API khác. Ví dụ, danh sách các pod đang chạy trên node được lấy bằng cách truy vấn các đối tượng **Pod** thông qua tài nguyên **pods**.

Nếu bạn tự chạy lệnh **describe**, có thể sẽ không có sự kiện nào được hiển thị. Điều này là do chỉ những sự kiện xảy ra gần đây mới được hiển thị.

Đối với đối tượng **Node**, trừ khi node có vấn đề về dung lượng tài nguyên, bạn sẽ chỉ thấy sự kiện nếu bạn vừa mới (re)start node.

Gần như mọi loại đối tượng API đều có các sự kiện liên quan đến nó. Vì chúng rất quan trọng cho việc debug cluster, chúng ta sẽ tìm hiểu kỹ hơn trước khi khám phá các đối tượng khác.



## **4.3 Quan sát các sự kiện trong cụm thông qua đối tượng Event**
Khi các controller thực hiện nhiệm vụ hòa giải (reconcile) trạng thái thực tế của một đối tượng với trạng thái mong muốn được chỉ định trong trường *spec* của đối tượng, chúng sẽ tạo ra các sự kiện (event) để cho thấy những gì chúng đã làm. Có hai loại sự kiện: **Normal** và **Warning**. Các sự kiện thuộc loại **Warning** thường được tạo ra bởi controller khi có điều gì đó ngăn chúng hòa giải đối tượng. Bằng cách giám sát loại sự kiện này, bạn có thể nhanh chóng được thông báo về bất kỳ vấn đề nào mà cụm gặp phải.

### 4.3.1 Giới thiệu về đối tượng Event

Giống như mọi thứ khác trong Kubernetes, các sự kiện được biểu diễn bởi các đối tượng **Event** được tạo và đọc thông qua Kubernetes API. Như hình sau đây minh họa, chúng chứa thông tin về những gì đã xảy ra với đối tượng và nguồn gốc của sự kiện. Không giống như các đối tượng khác, mỗi đối tượng **Event** sẽ bị xóa sau một giờ kể từ khi được tạo để giảm gánh nặng cho **etcd**, kho dữ liệu lưu trữ các đối tượng API của Kubernetes.

**Hình 4.7** Mối quan hệ giữa các đối tượng Event, controller và các đối tượng API khác.

![](https://img001.prntscr.com/file/img001/dDs4oHtjR9e0MHKbhQvecg.png)
**Lưu ý**
Thời gian lưu trữ sự kiện có thể được cấu hình thông qua các tùy chọn dòng lệnh của API server.

---

### Liệt kê các sự kiện bằng `kubectl get events`

Các sự kiện được hiển thị bởi `kubectl describe` liên quan đến đối tượng mà bạn chỉ định làm đối số cho lệnh. Do bản chất và thực tế là nhiều sự kiện có thể được tạo cho một đối tượng trong thời gian ngắn, chúng không phải là một phần của chính đối tượng. Bạn sẽ không tìm thấy chúng trong YAML manifest của đối tượng, vì chúng tồn tại độc lập, giống như **Node** và các đối tượng khác mà bạn đã thấy cho đến nay.

**Lưu ý**
Nếu bạn muốn thực hiện các bài tập trong phần này trên cụm của riêng mình, bạn có thể cần khởi động lại một trong các node để đảm bảo rằng các sự kiện đủ mới để vẫn tồn tại trong etcd. Nếu không thể làm điều này, đừng lo, chỉ cần bỏ qua và không tự làm các bài tập này, vì bạn cũng sẽ tạo và kiểm tra sự kiện trong các bài tập ở chương tiếp theo.

Vì **Event** là các đối tượng độc lập, bạn có thể liệt kê chúng bằng lệnh:

```bash
$ kubectl get ev
```

Kết quả ví dụ:

```
LAST SEEN   TYPE      REASON                    OBJECT             MESSAGE
48s         Normal    Starting                  node/kind-worker2   Starting kubelet.
48s         Normal    NodeAllocatableEnforced   node/kind-worker2   Updated Node A...
48s         Normal    NodeHasSufficientMemory   node/kind-worker2   Node kind-work...
48s         Normal    NodeHasNoDiskPressure     node/kind-worker2   Node kind-work...
48s         Normal    NodeHasSufficientPID      node/kind-worker2   Node kind-work...
47s         Normal    Starting                  node/kind-worker2   Starting kube-...
```

**Lưu ý**
Danh sách trước đó sử dụng tên viết tắt **ev** thay cho **events**.

Bạn sẽ nhận thấy rằng một số sự kiện hiển thị trong danh sách khớp với **status condition** của Node. Điều này thường xảy ra, nhưng bạn cũng sẽ thấy các sự kiện bổ sung khác. Hai sự kiện với lý do **Starting** là ví dụ điển hình. Trong trường hợp này, chúng báo hiệu rằng các thành phần **Kubelet** và **Kube Proxy** đã được khởi động trên node. Bạn chưa cần lo lắng về các thành phần này. Chúng sẽ được giải thích trong phần ba của cuốn sách.

---

### Hiểu những gì có trong đối tượng Event

Cũng như các đối tượng khác, lệnh `kubectl get` chỉ xuất ra dữ liệu quan trọng nhất của đối tượng. Để hiển thị thêm thông tin, bạn có thể bật các cột bổ sung bằng cách thực hiện lệnh với tùy chọn `-o wide`:

```bash
$ kubectl get ev -o wide
```

Kết quả của lệnh này rất rộng nên không được liệt kê trong sách. Thay vào đó, thông tin được giải thích trong bảng sau.

**Bảng 4.1 Các thuộc tính của đối tượng Event**

| Thuộc tính     | Mô tả                                                                                                                                               |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Name**       | Tên của instance đối tượng Event này. Chỉ hữu ích khi bạn muốn truy xuất đối tượng từ API.                                                          |
| **Type**       | Loại sự kiện. Có thể là **Normal** hoặc **Warning**.                                                                                                |
| **Reason**     | Mô tả dạng máy về lý do sự kiện xảy ra.                                                                                                             |
| **Source**     | Thành phần đã báo cáo sự kiện này. Thường là một controller.                                                                                        |
| **Object**     | Instance đối tượng mà sự kiện đề cập đến. Ví dụ: node/xyz.                                                                                          |
| **Subobject**  | Thành phần con mà sự kiện đề cập đến. Ví dụ: container nào của pod.                                                                                 |
| **Message**    | Mô tả dạng con người của sự kiện.                                                                                                                   |
| **First seen** | Lần đầu tiên sự kiện này xảy ra. Lưu ý mỗi đối tượng Event bị xóa sau một thời gian, nên đây có thể không phải lần đầu tiên thực tế sự kiện xảy ra. |
| **Last seen**  | Sự kiện thường xảy ra lặp lại. Trường này cho biết lần cuối cùng sự kiện xảy ra.                                                                    |
| **Count**      | Số lần sự kiện này đã xảy ra.                                                                                                                       |

**Mẹo**
Khi bạn thực hiện các bài tập trong suốt cuốn sách này, bạn có thể thấy hữu ích khi chạy lệnh `kubectl get events` mỗi khi thay đổi một trong các đối tượng của mình. Điều này sẽ giúp bạn học được những gì diễn ra bên dưới.

---

### Chỉ hiển thị các sự kiện cảnh báo

Không giống như lệnh `kubectl describe`, chỉ hiển thị các sự kiện liên quan đến đối tượng bạn đang mô tả, lệnh `kubectl get events` hiển thị tất cả các sự kiện. Điều này hữu ích nếu bạn muốn kiểm tra xem có sự kiện nào cần quan tâm hay không. Bạn có thể bỏ qua các sự kiện loại **Normal** và chỉ tập trung vào các sự kiện loại **Warning**.

API cung cấp một cách để lọc các đối tượng thông qua cơ chế gọi là **field selector**. Chỉ những đối tượng mà trường được chỉ định khớp với giá trị được chỉ định mới được trả về. Bạn có thể sử dụng điều này để chỉ hiển thị các sự kiện **Warning**.

Lệnh `kubectl get` cho phép bạn chỉ định **field selector** bằng tùy chọn `--field-selector`. Để chỉ liệt kê các sự kiện cảnh báo, bạn thực hiện lệnh:

```bash
$ kubectl get ev --field-selector type=Warning
```

Kết quả:

```
No resources found in default namespace.
```

Nếu lệnh không in ra sự kiện nào, như trong trường hợp trên, nghĩa là không có cảnh báo nào được ghi nhận gần đây trong cụm của bạn.

Bạn có thể tự hỏi làm thế nào tôi biết chính xác tên trường cần sử dụng trong **field selector** và giá trị chính xác của nó là gì (ví dụ có thể là chữ thường). Nếu bạn đoán rằng thông tin này được cung cấp bởi lệnh `kubectl explain events` thì chính xác rồi. Vì **Event** là các đối tượng API thông thường, bạn có thể sử dụng lệnh này để tra cứu tài liệu về cấu trúc của các đối tượng sự kiện. Ở đó, bạn sẽ thấy rằng trường **type** có thể có hai giá trị: **Normal** hoặc **Warning**.


### **4.3.2 Kiểm tra YAML của đối tượng Event**
Để kiểm tra các sự kiện trong cụm của bạn, các lệnh `kubectl describe` và `kubectl get events` là đủ. Không giống như các đối tượng khác, bạn có thể sẽ không bao giờ cần phải hiển thị toàn bộ YAML của một đối tượng Event. Nhưng tôi muốn nhân cơ hội này để chỉ ra một điều khó chịu về các bản kê khai (manifest) của đối tượng Kubernetes mà API trả về.

**Đối tượng Event không có phần spec và status**
Nếu bạn sử dụng `kubectl explain` để khám phá cấu trúc của đối tượng Event, bạn sẽ nhận thấy rằng nó không có phần **spec** hoặc **status**. Thật không may, điều này có nghĩa là các trường của nó không được tổ chức gọn gàng như trong đối tượng Node, chẳng hạn.
Hãy kiểm tra YAML sau và xem bạn có thể dễ dàng tìm thấy kiểu đối tượng, metadata, và các trường khác của đối tượng này hay không:

```yaml
apiVersion: v1 #A
count: 1
eventTime: null
firstTimestamp: "2020-05-17T18:16:40Z"
involvedObject:
  kind: Node
  name: kind-worker2
  uid: kind-worker2
kind: Event #B
lastTimestamp: "2020-05-17T18:16:40Z"
message: Starting kubelet.
metadata: #C
  creationTimestamp: "2020-05-17T18:16:40Z"
  name: kind-worker2.160fe38fc0bc3703 #D
  namespace: default
  resourceVersion: "3528471"
  selfLink: /api/v1/namespaces/default/events/kind-worker2.160f...
  uid: da97e812-d89e-4890-9663-091fd1ec5e2d
reason: Starting
reportingComponent: ""
reportingInstance: ""
source:
  component: kubelet
  host: kind-worker2
type: Normal
```

Chắc chắn bạn sẽ đồng ý rằng YAML manifest trong ví dụ này rất lộn xộn. Các trường được liệt kê theo thứ tự bảng chữ cái thay vì được tổ chức thành các nhóm logic. Điều này khiến chúng ta, con người, khó đọc. Nó trông hỗn loạn đến mức không có gì ngạc nhiên khi nhiều người ghét làm việc với YAML hoặc JSON của Kubernetes, vì cả hai đều gặp phải vấn đề này.

Ngược lại, YAML manifest của đối tượng Node trước đó khá dễ đọc, vì thứ tự của các trường cấp cao nhất là những gì mà người ta mong đợi: **apiVersion**, **kind**, **metadata**, **spec**, và **status**. Bạn sẽ nhận thấy rằng điều này đơn giản chỉ vì thứ tự bảng chữ cái của năm trường này tình cờ hợp lý. Nhưng các trường bên dưới những trường này cũng gặp phải vấn đề tương tự, vì chúng cũng được sắp xếp theo bảng chữ cái.

YAML đáng lẽ phải dễ đọc đối với con người, nhưng việc sắp xếp các trường theo bảng chữ cái trong YAML của Kubernetes lại phá vỡ điều này. May mắn thay, hầu hết các đối tượng đều chứa phần **spec** và **status**, vì vậy ít nhất các trường cấp cao nhất trong những đối tượng này được tổ chức tốt. Còn về phần còn lại, bạn chỉ cần chấp nhận khía cạnh không may này khi làm việc với các manifest của Kubernetes.

---

## **4.4 Tóm tắt**
Trong chương này, bạn đã học được:

* Kubernetes cung cấp một API RESTful để tương tác với cụm. Các đối tượng API ánh xạ đến các thành phần thực tế tạo nên cụm, bao gồm ứng dụng, bộ cân bằng tải, node, ổ lưu trữ, và nhiều thành phần khác.
* Một instance đối tượng có thể được biểu diễn bởi nhiều tài nguyên. Một kiểu đối tượng có thể được hiển thị thông qua nhiều tài nguyên khác nhau chỉ là các biểu diễn khác nhau của cùng một thực thể.
* Các đối tượng API của Kubernetes được mô tả trong YAML hoặc JSON manifest. Các đối tượng được tạo bằng cách gửi một manifest đến API. Trạng thái của đối tượng được lưu trữ trong chính đối tượng và có thể được truy xuất bằng cách yêu cầu đối tượng từ API với một yêu cầu GET.
* Tất cả các đối tượng API của Kubernetes đều chứa **Type** và **Object Metadata**, và hầu hết đều có phần **spec** và **status**. Một vài kiểu đối tượng không có hai phần này, vì chúng chỉ chứa dữ liệu tĩnh.
* Controllers làm cho các đối tượng trở nên "sống" bằng cách liên tục theo dõi sự thay đổi trong **spec**, cập nhật trạng thái cụm và báo cáo trạng thái hiện tại thông qua trường **status** của đối tượng.
* Khi controllers quản lý các đối tượng API của Kubernetes, chúng phát ra các sự kiện để tiết lộ những hành động mà chúng đã thực hiện. Giống như mọi thứ khác, các sự kiện được biểu diễn bằng các đối tượng Event và có thể được truy xuất thông qua API.
* Các sự kiện cho biết những gì đang xảy ra với một Node hoặc đối tượng khác. Chúng hiển thị những gì đã xảy ra gần đây với đối tượng và có thể cung cấp manh mối về lý do tại sao nó bị lỗi.
* Lệnh `kubectl explain` cung cấp một cách nhanh chóng để tra cứu tài liệu về một loại đối tượng cụ thể và các trường của nó ngay từ dòng lệnh.
* **Status** trong một đối tượng Node chứa thông tin về địa chỉ IP và tên máy của node, dung lượng tài nguyên, các điều kiện, hình ảnh container đã được cache và thông tin khác về node. Các Pod chạy trên node không phải là một phần của status của node, nhưng lệnh `kubectl describe node` lấy thông tin này từ tài nguyên pods.
* Nhiều loại đối tượng sử dụng các điều kiện trạng thái (**status conditions**) để báo hiệu trạng thái của thành phần mà đối tượng đại diện. Đối với node, các điều kiện này là **MemoryPressure**, **DiskPressure** và **PIDPressure**. Mỗi điều kiện là **True**, **False**, hoặc **Unknown** và có một lý do cùng thông báo giải thích tại sao điều kiện ở trạng thái được chỉ định.

Bây giờ bạn nên quen thuộc với cấu trúc chung của các đối tượng API trong Kubernetes. Trong chương tiếp theo, bạn sẽ tìm hiểu về đối tượng **Pod**, khối xây dựng cơ bản đại diện cho một instance đang chạy của ứng dụng của bạn.
